<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }

        #container {
            height: 100%;
        }

        #container.loading {
            background-color: #backcolor;
            font-family: #loadingfont;
            font-size: #loadingfontsize;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="container" class="loading"><span id="loading">Loading Monaco Editor...</span></div>
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.55.0-dev-20251022/dev/vs/loader.js"></script>
    <script>
        require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.55.0-dev-20251022/dev/vs' } });
    </script>
    <script>
        require(['vs/editor/editor.main'], async function () {
            // Get the value and language that have been set in .NET before the editor has loaded
            const value = await window.chrome.webview.hostObjects.monacoBridge.GetInitValue();
            const language = await window.chrome.webview.hostObjects.monacoBridge.GetLanguage();
            //const uri = await window.chrome.webview.hostObjects.monacoBridge.GetUri();

            window.editor = monaco.editor.create(document.getElementById('container'), {
                value: value,
                language: language
            });

            editor.onDidChangeModelLanguageConfiguration(() => {
                // Editor has loaded so remove loading notification
                document.getElementById('container').classList.remove('loading');
                const loading = document.getElementById('loading');
                loading.parentElement.removeChild(loading);
            });

            const getUri = function () {
                return editor.getModel().uri.toString();
            };

            window.setUri = function (uri) {
                const oldModel = editor.getModel();
                const newUri = monaco.Uri.parse(uri);
                const newModel = monaco.editor.createModel(
                    oldModel.getValue(),
                    oldModel.getLanguageId(),
                    newUri);
                editor.setModel(newModel);
                oldModel.dispose();
            }

            const sendLspRequest = async function (method, params) {
                const request = {
                    "jsonrpc": "2.0",
                    "method": method,
                    "params": params
                };

                const resultJson = await window.chrome.webview.hostObjects.lspTransport.SendRequest(JSON.stringify(request));
                return JSON.parse(resultJson);
            };

            const sendLspNotification = async function (method, params) {
                const request = {
                    "jsonrpc": "2.0",
                    "method": method,
                    "params": params
                };

                await window.chrome.webview.hostObjects.lspTransport.SendNotification(JSON.stringify(request));
            };

            //
            // LSP integration
            //
            window.registerLsp = async function (language) {

                // Initialize the LSP
                const initializeResult = await sendLspRequest("initialize", {
                    processId: null,
                    clientInfo: { name: "MarkMpn.WinformsMonaco", version: "1.0" },
                    rootUri: null,
                    capabilities: {
                        textDocument: {
                            completion: {
                                completionItem: {
                                    snippetSupport: true
                                }
                            },
                            hover: {},
                        },
                        workspace: {}
                    },
                    workspaceFolders: null
                });

                const triggerChars = initializeResult?.capabilities?.completionProvider?.triggerCharacters || [];

                if (triggerChars) {
                    monaco.languages.registerCompletionItemProvider(language, {
                        triggerCharacters: triggerChars,
                        provideCompletionItems: async function (model, position, context, token) {
                            const result = await sendLspRequest("textDocument/completion", {
                                textDocument: { uri: getUri() },
                                position: {
                                    line: position.lineNumber - 1,
                                    character: position.column - 1
                                },
                                context: {
                                    triggerKind: context.triggerKind,
                                    triggerCharacter: context.triggerCharacter
                                }
                            });

                            const items = result.items || [];

                            return {
                                suggestions: items.map(item => {
                                    return {
                                        label: item.label,
                                        kind: monaco.languages.CompletionItemKind[item.kind] || monaco.languages.CompletionItemKind.Text,
                                        insertText: item.insertText || item.label,
                                        documentation: item.documentation,
                                        detail: item.detail,
                                        sortText: item.sortText,
                                        filterText: item.filterText,
                                        range: undefined
                                    };
                                })
                            };
                        }
                    });
                }

                if (initializeResult?.capabilities?.hoverProvider) {
                    monaco.languages.registerHoverProvider(language, {
                        provideHover: async function (model, position, token) {
                            const result = sendLspRequest("textDocument/hover", {
                                textDocument: { uri: getUri() },
                                position: {
                                    line: position.lineNumber - 1,
                                    character: position.column - 1
                                }
                            });

                            if (!result || !result.contents)
                                return null;

                            return {
                                contents: Array.isArray(result.contents)
                                    ? result.contents.map(c => ({ value: typeof c === 'string' ? c : c.value }))
                                    : [{ value: typeof result.contents === 'string' ? result.contents : result.contents.value }]
                            };
                        }
                    });
                }

                if (initializeResult?.capabilities?.documentFormattingProvider) {
                    monaco.languages.registerDocumentFormattingEditProvider(language, {
                        provideDocumentFormattingEdits: async function (model, options, token) {
                            const result = await sendLspRequest("textDocument/formatting", {
                                textDocument: { uri: getUri() },
                                options: {
                                    tabSize: options.tabSize,
                                    insertSpaces: options.insertSpaces
                                }
                            });

                            return result.map(edit => {
                                return {
                                    range: new monaco.Range(
                                        edit.range.start.line + 1,
                                        edit.range.start.character + 1,
                                        edit.range.end.line + 1,
                                        edit.range.end.character + 1),
                                    text: edit.newText
                                };
                            });
                        }
                    });
                }

                if (initializeResult?.capabilities?.textDocumentSync) {
                    const model = editor.getModel();

                    model.onDidChangeContent(async (e) => {
                        if (initializeResult?.capabilities?.textDocumentSync?.change === 1) {
                            // Full sync
                            await sendLspNotification("textDocument/didChange", {
                                textDocument: {
                                    uri: getUri(),
                                    version: editor.getModel().getVersionId()
                                },
                                contentChanges: [
                                    {
                                        text: editor.getModel().getValue()
                                    }
                                ]
                            });
                        } else if (initializeResult?.capabilities?.textDocumentSync?.change === 2) {
                            // Incremental sync
                            await sendLspNotification("textDocument/didChange", {
                                textDocument: {
                                    uri: getUri(),
                                    version: editor.getModel().getVersionId()
                                },
                                contentChanges: e.changes.map(change => ({
                                    range: {
                                        start: { line: change.range.startLineNumber - 1, character: change.range.startColumn - 1 },
                                        end: { line: change.range.endLineNumber - 1, character: change.range.endColumn - 1 }
                                    },
                                    text: change.text
                                }))
                            });
                        }
                    });

                    if (initializeResult?.capabilities?.textDocumentSync?.openClose) {
                        model.onDidSave(async () => {
                            const params = {
                                textDocument: { uri: getUri() },
                                text: initializeResult?.capabilities?.textDocumentSync?.save?.includeText ? model.getValue() : undefined
                            };

                            await sendLspNotification("textDocument/didSave", params);
                        });

                        model.onDidDispose(async () => {
                            const params = {
                                textDocument: { uri: model.uri.toString() }
                            };

                            await sendLspNotification("textDocument/didClose", params);
                        });
                    }

                    // Send the initial open notification
                    await sendLspNotification("textDocument/didOpen", {
                        textDocument: {
                            uri: getUri(),
                            languageId: language,
                            version: editor.getModel().getVersionId(),
                            text: editor.getModel().getValue()
                        }
                    });
                }

                await sendLspNotification("initialized", {});
            };

            window.lspClient = {
                handleNotification: function (method, params) {
                    if (method === "textDocument/publishDiagnostics") {
                        const { uri, diagnostics } = params;

                        const model = monaco.editor.getModels().find(m => m.uri.toString() === uri);
                        if (!model) return;

                        monaco.editor.setModelMarkers(
                            model,
                            'lsp',
                            params.diagnostics.map(d => ({
                                startLineNumber: d.range.start.line + 1,
                                startColumn: d.range.start.character + 1,
                                endLineNumber: d.range.end.line + 1,
                                endColumn: d.range.end.character + 1,
                                message: d.message,
                                severity: monaco.MarkerSeverity[d.severity] || monaco.MarkerSeverity.Info
                            }))
                        );
                    }
                }
            };
        });
    </script>
</body>
</html>